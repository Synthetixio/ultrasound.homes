{"version":3,"file":"chunk/1473.40895dc1.js","mappings":"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","sources":["webpack://@snx-v3/ultrasound-homes/../../node_modules/@web3-onboard/ledger/node_modules/@ethersproject/providers/lib.esm/_version.js","webpack://@snx-v3/ultrasound-homes/../../node_modules/@web3-onboard/ledger/node_modules/@ethersproject/providers/lib.esm/formatter.js","webpack://@snx-v3/ultrasound-homes/../../node_modules/@web3-onboard/ledger/node_modules/@ethersproject/providers/lib.esm/base-provider.js","webpack://@snx-v3/ultrasound-homes/../../node_modules/@web3-onboard/ledger/node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js","webpack://@snx-v3/ultrasound-homes/../../node_modules/@web3-onboard/ledger/node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js","webpack://@snx-v3/ultrasound-homes/../../node_modules/@web3-onboard/ledger/node_modules/@ethersproject/providers/lib.esm/index.js"],"sourcesContent":["export const version = \"providers/5.5.0\";\n//# sourceMappingURL=_version.js.map","\"use strict\";\nimport { getAddress, getContractAddress } from \"@ethersproject/address\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { hexDataLength, hexDataSlice, hexValue, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { AddressZero } from \"@ethersproject/constants\";\nimport { shallowCopy } from \"@ethersproject/properties\";\nimport { accessListify, parse as parseTransaction } from \"@ethersproject/transactions\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nexport class Formatter {\n    constructor() {\n        logger.checkNew(new.target, Formatter);\n        this.formats = this.getDefaultFormats();\n    }\n    getDefaultFormats() {\n        const formats = ({});\n        const address = this.address.bind(this);\n        const bigNumber = this.bigNumber.bind(this);\n        const blockTag = this.blockTag.bind(this);\n        const data = this.data.bind(this);\n        const hash = this.hash.bind(this);\n        const hex = this.hex.bind(this);\n        const number = this.number.bind(this);\n        const type = this.type.bind(this);\n        const strictData = (v) => { return this.data(v, true); };\n        formats.transaction = {\n            hash: hash,\n            type: type,\n            accessList: Formatter.allowNull(this.accessList.bind(this), null),\n            blockHash: Formatter.allowNull(hash, null),\n            blockNumber: Formatter.allowNull(number, null),\n            transactionIndex: Formatter.allowNull(number, null),\n            confirmations: Formatter.allowNull(number, null),\n            from: address,\n            // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas)\n            // must be set\n            gasPrice: Formatter.allowNull(bigNumber),\n            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),\n            maxFeePerGas: Formatter.allowNull(bigNumber),\n            gasLimit: bigNumber,\n            to: Formatter.allowNull(address, null),\n            value: bigNumber,\n            nonce: number,\n            data: data,\n            r: Formatter.allowNull(this.uint256),\n            s: Formatter.allowNull(this.uint256),\n            v: Formatter.allowNull(number),\n            creates: Formatter.allowNull(address, null),\n            raw: Formatter.allowNull(data),\n        };\n        formats.transactionRequest = {\n            from: Formatter.allowNull(address),\n            nonce: Formatter.allowNull(number),\n            gasLimit: Formatter.allowNull(bigNumber),\n            gasPrice: Formatter.allowNull(bigNumber),\n            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),\n            maxFeePerGas: Formatter.allowNull(bigNumber),\n            to: Formatter.allowNull(address),\n            value: Formatter.allowNull(bigNumber),\n            data: Formatter.allowNull(strictData),\n            type: Formatter.allowNull(number),\n            accessList: Formatter.allowNull(this.accessList.bind(this), null),\n        };\n        formats.receiptLog = {\n            transactionIndex: number,\n            blockNumber: number,\n            transactionHash: hash,\n            address: address,\n            topics: Formatter.arrayOf(hash),\n            data: data,\n            logIndex: number,\n            blockHash: hash,\n        };\n        formats.receipt = {\n            to: Formatter.allowNull(this.address, null),\n            from: Formatter.allowNull(this.address, null),\n            contractAddress: Formatter.allowNull(address, null),\n            transactionIndex: number,\n            // should be allowNull(hash), but broken-EIP-658 support is handled in receipt\n            root: Formatter.allowNull(hex),\n            gasUsed: bigNumber,\n            logsBloom: Formatter.allowNull(data),\n            blockHash: hash,\n            transactionHash: hash,\n            logs: Formatter.arrayOf(this.receiptLog.bind(this)),\n            blockNumber: number,\n            confirmations: Formatter.allowNull(number, null),\n            cumulativeGasUsed: bigNumber,\n            effectiveGasPrice: Formatter.allowNull(bigNumber),\n            status: Formatter.allowNull(number),\n            type: type\n        };\n        formats.block = {\n            hash: hash,\n            parentHash: hash,\n            number: number,\n            timestamp: number,\n            nonce: Formatter.allowNull(hex),\n            difficulty: this.difficulty.bind(this),\n            gasLimit: bigNumber,\n            gasUsed: bigNumber,\n            miner: address,\n            extraData: data,\n            transactions: Formatter.allowNull(Formatter.arrayOf(hash)),\n            baseFeePerGas: Formatter.allowNull(bigNumber)\n        };\n        formats.blockWithTransactions = shallowCopy(formats.block);\n        formats.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));\n        formats.filter = {\n            fromBlock: Formatter.allowNull(blockTag, undefined),\n            toBlock: Formatter.allowNull(blockTag, undefined),\n            blockHash: Formatter.allowNull(hash, undefined),\n            address: Formatter.allowNull(address, undefined),\n            topics: Formatter.allowNull(this.topics.bind(this), undefined),\n        };\n        formats.filterLog = {\n            blockNumber: Formatter.allowNull(number),\n            blockHash: Formatter.allowNull(hash),\n            transactionIndex: number,\n            removed: Formatter.allowNull(this.boolean.bind(this)),\n            address: address,\n            data: Formatter.allowFalsish(data, \"0x\"),\n            topics: Formatter.arrayOf(hash),\n            transactionHash: hash,\n            logIndex: number,\n        };\n        return formats;\n    }\n    accessList(accessList) {\n        return accessListify(accessList || []);\n    }\n    // Requires a BigNumberish that is within the IEEE754 safe integer range; returns a number\n    // Strict! Used on input.\n    number(number) {\n        if (number === \"0x\") {\n            return 0;\n        }\n        return BigNumber.from(number).toNumber();\n    }\n    type(number) {\n        if (number === \"0x\" || number == null) {\n            return 0;\n        }\n        return BigNumber.from(number).toNumber();\n    }\n    // Strict! Used on input.\n    bigNumber(value) {\n        return BigNumber.from(value);\n    }\n    // Requires a boolean, \"true\" or  \"false\"; returns a boolean\n    boolean(value) {\n        if (typeof (value) === \"boolean\") {\n            return value;\n        }\n        if (typeof (value) === \"string\") {\n            value = value.toLowerCase();\n            if (value === \"true\") {\n                return true;\n            }\n            if (value === \"false\") {\n                return false;\n            }\n        }\n        throw new Error(\"invalid boolean - \" + value);\n    }\n    hex(value, strict) {\n        if (typeof (value) === \"string\") {\n            if (!strict && value.substring(0, 2) !== \"0x\") {\n                value = \"0x\" + value;\n            }\n            if (isHexString(value)) {\n                return value.toLowerCase();\n            }\n        }\n        return logger.throwArgumentError(\"invalid hash\", \"value\", value);\n    }\n    data(value, strict) {\n        const result = this.hex(value, strict);\n        if ((result.length % 2) !== 0) {\n            throw new Error(\"invalid data; odd-length - \" + value);\n        }\n        return result;\n    }\n    // Requires an address\n    // Strict! Used on input.\n    address(value) {\n        return getAddress(value);\n    }\n    callAddress(value) {\n        if (!isHexString(value, 32)) {\n            return null;\n        }\n        const address = getAddress(hexDataSlice(value, 12));\n        return (address === AddressZero) ? null : address;\n    }\n    contractAddress(value) {\n        return getContractAddress(value);\n    }\n    // Strict! Used on input.\n    blockTag(blockTag) {\n        if (blockTag == null) {\n            return \"latest\";\n        }\n        if (blockTag === \"earliest\") {\n            return \"0x0\";\n        }\n        if (blockTag === \"latest\" || blockTag === \"pending\") {\n            return blockTag;\n        }\n        if (typeof (blockTag) === \"number\" || isHexString(blockTag)) {\n            return hexValue(blockTag);\n        }\n        throw new Error(\"invalid blockTag\");\n    }\n    // Requires a hash, optionally requires 0x prefix; returns prefixed lowercase hash.\n    hash(value, strict) {\n        const result = this.hex(value, strict);\n        if (hexDataLength(result) !== 32) {\n            return logger.throwArgumentError(\"invalid hash\", \"value\", value);\n        }\n        return result;\n    }\n    // Returns the difficulty as a number, or if too large (i.e. PoA network) null\n    difficulty(value) {\n        if (value == null) {\n            return null;\n        }\n        const v = BigNumber.from(value);\n        try {\n            return v.toNumber();\n        }\n        catch (error) { }\n        return null;\n    }\n    uint256(value) {\n        if (!isHexString(value)) {\n            throw new Error(\"invalid uint256\");\n        }\n        return hexZeroPad(value, 32);\n    }\n    _block(value, format) {\n        if (value.author != null && value.miner == null) {\n            value.miner = value.author;\n        }\n        // The difficulty may need to come from _difficulty in recursed blocks\n        const difficulty = (value._difficulty != null) ? value._difficulty : value.difficulty;\n        const result = Formatter.check(format, value);\n        result._difficulty = ((difficulty == null) ? null : BigNumber.from(difficulty));\n        return result;\n    }\n    block(value) {\n        return this._block(value, this.formats.block);\n    }\n    blockWithTransactions(value) {\n        return this._block(value, this.formats.blockWithTransactions);\n    }\n    // Strict! Used on input.\n    transactionRequest(value) {\n        return Formatter.check(this.formats.transactionRequest, value);\n    }\n    transactionResponse(transaction) {\n        // Rename gas to gasLimit\n        if (transaction.gas != null && transaction.gasLimit == null) {\n            transaction.gasLimit = transaction.gas;\n        }\n        // Some clients (TestRPC) do strange things like return 0x0 for the\n        // 0 address; correct this to be a real address\n        if (transaction.to && BigNumber.from(transaction.to).isZero()) {\n            transaction.to = \"0x0000000000000000000000000000000000000000\";\n        }\n        // Rename input to data\n        if (transaction.input != null && transaction.data == null) {\n            transaction.data = transaction.input;\n        }\n        // If to and creates are empty, populate the creates from the transaction\n        if (transaction.to == null && transaction.creates == null) {\n            transaction.creates = this.contractAddress(transaction);\n        }\n        if ((transaction.type === 1 || transaction.type === 2) && transaction.accessList == null) {\n            transaction.accessList = [];\n        }\n        const result = Formatter.check(this.formats.transaction, transaction);\n        if (transaction.chainId != null) {\n            let chainId = transaction.chainId;\n            if (isHexString(chainId)) {\n                chainId = BigNumber.from(chainId).toNumber();\n            }\n            result.chainId = chainId;\n        }\n        else {\n            let chainId = transaction.networkId;\n            // geth-etc returns chainId\n            if (chainId == null && result.v == null) {\n                chainId = transaction.chainId;\n            }\n            if (isHexString(chainId)) {\n                chainId = BigNumber.from(chainId).toNumber();\n            }\n            if (typeof (chainId) !== \"number\" && result.v != null) {\n                chainId = (result.v - 35) / 2;\n                if (chainId < 0) {\n                    chainId = 0;\n                }\n                chainId = parseInt(chainId);\n            }\n            if (typeof (chainId) !== \"number\") {\n                chainId = 0;\n            }\n            result.chainId = chainId;\n        }\n        // 0x0000... should actually be null\n        if (result.blockHash && result.blockHash.replace(/0/g, \"\") === \"x\") {\n            result.blockHash = null;\n        }\n        return result;\n    }\n    transaction(value) {\n        return parseTransaction(value);\n    }\n    receiptLog(value) {\n        return Formatter.check(this.formats.receiptLog, value);\n    }\n    receipt(value) {\n        const result = Formatter.check(this.formats.receipt, value);\n        // RSK incorrectly implemented EIP-658, so we munge things a bit here for it\n        if (result.root != null) {\n            if (result.root.length <= 4) {\n                // Could be 0x00, 0x0, 0x01 or 0x1\n                const value = BigNumber.from(result.root).toNumber();\n                if (value === 0 || value === 1) {\n                    // Make sure if both are specified, they match\n                    if (result.status != null && (result.status !== value)) {\n                        logger.throwArgumentError(\"alt-root-status/status mismatch\", \"value\", { root: result.root, status: result.status });\n                    }\n                    result.status = value;\n                    delete result.root;\n                }\n                else {\n                    logger.throwArgumentError(\"invalid alt-root-status\", \"value.root\", result.root);\n                }\n            }\n            else if (result.root.length !== 66) {\n                // Must be a valid bytes32\n                logger.throwArgumentError(\"invalid root hash\", \"value.root\", result.root);\n            }\n        }\n        if (result.status != null) {\n            result.byzantium = true;\n        }\n        return result;\n    }\n    topics(value) {\n        if (Array.isArray(value)) {\n            return value.map((v) => this.topics(v));\n        }\n        else if (value != null) {\n            return this.hash(value, true);\n        }\n        return null;\n    }\n    filter(value) {\n        return Formatter.check(this.formats.filter, value);\n    }\n    filterLog(value) {\n        return Formatter.check(this.formats.filterLog, value);\n    }\n    static check(format, object) {\n        const result = {};\n        for (const key in format) {\n            try {\n                const value = format[key](object[key]);\n                if (value !== undefined) {\n                    result[key] = value;\n                }\n            }\n            catch (error) {\n                error.checkKey = key;\n                error.checkValue = object[key];\n                throw error;\n            }\n        }\n        return result;\n    }\n    // if value is null-ish, nullValue is returned\n    static allowNull(format, nullValue) {\n        return (function (value) {\n            if (value == null) {\n                return nullValue;\n            }\n            return format(value);\n        });\n    }\n    // If value is false-ish, replaceValue is returned\n    static allowFalsish(format, replaceValue) {\n        return (function (value) {\n            if (!value) {\n                return replaceValue;\n            }\n            return format(value);\n        });\n    }\n    // Requires an Array satisfying check\n    static arrayOf(format) {\n        return (function (array) {\n            if (!Array.isArray(array)) {\n                throw new Error(\"not an array\");\n            }\n            const result = [];\n            array.forEach(function (value) {\n                result.push(format(value));\n            });\n            return result;\n        });\n    }\n}\nexport function isCommunityResourcable(value) {\n    return (value && typeof (value.isCommunityResource) === \"function\");\n}\nexport function isCommunityResource(value) {\n    return (isCommunityResourcable(value) && value.isCommunityResource());\n}\n// Show the throttle message only once\nlet throttleMessage = false;\nexport function showThrottleMessage() {\n    if (throttleMessage) {\n        return;\n    }\n    throttleMessage = true;\n    console.log(\"========= NOTICE =========\");\n    console.log(\"Request-Rate Exceeded  (this message will not be repeated)\");\n    console.log(\"\");\n    console.log(\"The default API keys for each service are provided as a highly-throttled,\");\n    console.log(\"community resource for low-traffic projects and early prototyping.\");\n    console.log(\"\");\n    console.log(\"While your application will continue to function, we highly recommended\");\n    console.log(\"signing up for your own API keys to improve performance, increase your\");\n    console.log(\"request rate/limit and enable other perks, such as metrics and advanced APIs.\");\n    console.log(\"\");\n    console.log(\"For more details: https:/\\/docs.ethers.io/api-keys/\");\n    console.log(\"==========================\");\n}\n//# sourceMappingURL=formatter.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ForkEvent, Provider } from \"@ethersproject/abstract-provider\";\nimport { Base58 } from \"@ethersproject/basex\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { arrayify, concat, hexConcat, hexDataLength, hexDataSlice, hexlify, hexValue, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { HashZero } from \"@ethersproject/constants\";\nimport { namehash } from \"@ethersproject/hash\";\nimport { getNetwork } from \"@ethersproject/networks\";\nimport { defineReadOnly, getStatic, resolveProperties } from \"@ethersproject/properties\";\nimport { sha256 } from \"@ethersproject/sha2\";\nimport { toUtf8Bytes, toUtf8String } from \"@ethersproject/strings\";\nimport { fetchJson, poll } from \"@ethersproject/web\";\nimport bech32 from \"bech32\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { Formatter } from \"./formatter\";\n//////////////////////////////\n// Event Serializeing\nfunction checkTopic(topic) {\n    if (topic == null) {\n        return \"null\";\n    }\n    if (hexDataLength(topic) !== 32) {\n        logger.throwArgumentError(\"invalid topic\", \"topic\", topic);\n    }\n    return topic.toLowerCase();\n}\nfunction serializeTopics(topics) {\n    // Remove trailing null AND-topics; they are redundant\n    topics = topics.slice();\n    while (topics.length > 0 && topics[topics.length - 1] == null) {\n        topics.pop();\n    }\n    return topics.map((topic) => {\n        if (Array.isArray(topic)) {\n            // Only track unique OR-topics\n            const unique = {};\n            topic.forEach((topic) => {\n                unique[checkTopic(topic)] = true;\n            });\n            // The order of OR-topics does not matter\n            const sorted = Object.keys(unique);\n            sorted.sort();\n            return sorted.join(\"|\");\n        }\n        else {\n            return checkTopic(topic);\n        }\n    }).join(\"&\");\n}\nfunction deserializeTopics(data) {\n    if (data === \"\") {\n        return [];\n    }\n    return data.split(/&/g).map((topic) => {\n        if (topic === \"\") {\n            return [];\n        }\n        const comps = topic.split(\"|\").map((topic) => {\n            return ((topic === \"null\") ? null : topic);\n        });\n        return ((comps.length === 1) ? comps[0] : comps);\n    });\n}\nfunction getEventTag(eventName) {\n    if (typeof (eventName) === \"string\") {\n        eventName = eventName.toLowerCase();\n        if (hexDataLength(eventName) === 32) {\n            return \"tx:\" + eventName;\n        }\n        if (eventName.indexOf(\":\") === -1) {\n            return eventName;\n        }\n    }\n    else if (Array.isArray(eventName)) {\n        return \"filter:*:\" + serializeTopics(eventName);\n    }\n    else if (ForkEvent.isForkEvent(eventName)) {\n        logger.warn(\"not implemented\");\n        throw new Error(\"not implemented\");\n    }\n    else if (eventName && typeof (eventName) === \"object\") {\n        return \"filter:\" + (eventName.address || \"*\") + \":\" + serializeTopics(eventName.topics || []);\n    }\n    throw new Error(\"invalid event - \" + eventName);\n}\n//////////////////////////////\n// Helper Object\nfunction getTime() {\n    return (new Date()).getTime();\n}\nfunction stall(duration) {\n    return new Promise((resolve) => {\n        setTimeout(resolve, duration);\n    });\n}\n//////////////////////////////\n// Provider Object\n/**\n *  EventType\n *   - \"block\"\n *   - \"poll\"\n *   - \"didPoll\"\n *   - \"pending\"\n *   - \"error\"\n *   - \"network\"\n *   - filter\n *   - topics array\n *   - transaction hash\n */\nconst PollableEvents = [\"block\", \"network\", \"pending\", \"poll\"];\nexport class Event {\n    constructor(tag, listener, once) {\n        defineReadOnly(this, \"tag\", tag);\n        defineReadOnly(this, \"listener\", listener);\n        defineReadOnly(this, \"once\", once);\n    }\n    get event() {\n        switch (this.type) {\n            case \"tx\":\n                return this.hash;\n            case \"filter\":\n                return this.filter;\n        }\n        return this.tag;\n    }\n    get type() {\n        return this.tag.split(\":\")[0];\n    }\n    get hash() {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== \"tx\") {\n            return null;\n        }\n        return comps[1];\n    }\n    get filter() {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== \"filter\") {\n            return null;\n        }\n        const address = comps[1];\n        const topics = deserializeTopics(comps[2]);\n        const filter = {};\n        if (topics.length > 0) {\n            filter.topics = topics;\n        }\n        if (address && address !== \"*\") {\n            filter.address = address;\n        }\n        return filter;\n    }\n    pollable() {\n        return (this.tag.indexOf(\":\") >= 0 || PollableEvents.indexOf(this.tag) >= 0);\n    }\n}\n;\n// https://github.com/satoshilabs/slips/blob/master/slip-0044.md\nconst coinInfos = {\n    \"0\": { symbol: \"btc\", p2pkh: 0x00, p2sh: 0x05, prefix: \"bc\" },\n    \"2\": { symbol: \"ltc\", p2pkh: 0x30, p2sh: 0x32, prefix: \"ltc\" },\n    \"3\": { symbol: \"doge\", p2pkh: 0x1e, p2sh: 0x16 },\n    \"60\": { symbol: \"eth\", ilk: \"eth\" },\n    \"61\": { symbol: \"etc\", ilk: \"eth\" },\n    \"700\": { symbol: \"xdai\", ilk: \"eth\" },\n};\nfunction bytes32ify(value) {\n    return hexZeroPad(BigNumber.from(value).toHexString(), 32);\n}\n// Compute the Base58Check encoded data (checksum is first 4 bytes of sha256d)\nfunction base58Encode(data) {\n    return Base58.encode(concat([data, hexDataSlice(sha256(sha256(data)), 0, 4)]));\n}\nconst matchers = [\n    new RegExp(\"^(https):/\\/(.*)$\", \"i\"),\n    new RegExp(\"^(data):(.*)$\", \"i\"),\n    new RegExp(\"^(ipfs):/\\/(.*)$\", \"i\"),\n    new RegExp(\"^eip155:[0-9]+/(erc[0-9]+):(.*)$\", \"i\"),\n];\nfunction _parseString(result) {\n    try {\n        return toUtf8String(_parseBytes(result));\n    }\n    catch (error) { }\n    return null;\n}\nfunction _parseBytes(result) {\n    if (result === \"0x\") {\n        return null;\n    }\n    const offset = BigNumber.from(hexDataSlice(result, 0, 32)).toNumber();\n    const length = BigNumber.from(hexDataSlice(result, offset, offset + 32)).toNumber();\n    return hexDataSlice(result, offset + 32, offset + 32 + length);\n}\nexport class Resolver {\n    // The resolvedAddress is only for creating a ReverseLookup resolver\n    constructor(provider, address, name, resolvedAddress) {\n        defineReadOnly(this, \"provider\", provider);\n        defineReadOnly(this, \"name\", name);\n        defineReadOnly(this, \"address\", provider.formatter.address(address));\n        defineReadOnly(this, \"_resolvedAddress\", resolvedAddress);\n    }\n    _fetchBytes(selector, parameters) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // e.g. keccak256(\"addr(bytes32,uint256)\")\n            const tx = {\n                to: this.address,\n                data: hexConcat([selector, namehash(this.name), (parameters || \"0x\")])\n            };\n            try {\n                return _parseBytes(yield this.provider.call(tx));\n            }\n            catch (error) {\n                if (error.code === Logger.errors.CALL_EXCEPTION) {\n                    return null;\n                }\n                return null;\n            }\n        });\n    }\n    _getAddress(coinType, hexBytes) {\n        const coinInfo = coinInfos[String(coinType)];\n        if (coinInfo == null) {\n            logger.throwError(`unsupported coin type: ${coinType}`, Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: `getAddress(${coinType})`\n            });\n        }\n        if (coinInfo.ilk === \"eth\") {\n            return this.provider.formatter.address(hexBytes);\n        }\n        const bytes = arrayify(hexBytes);\n        // P2PKH: OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG\n        if (coinInfo.p2pkh != null) {\n            const p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);\n            if (p2pkh) {\n                const length = parseInt(p2pkh[1], 16);\n                if (p2pkh[2].length === length * 2 && length >= 1 && length <= 75) {\n                    return base58Encode(concat([[coinInfo.p2pkh], (\"0x\" + p2pkh[2])]));\n                }\n            }\n        }\n        // P2SH: OP_HASH160 <scriptHash> OP_EQUAL\n        if (coinInfo.p2sh != null) {\n            const p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);\n            if (p2sh) {\n                const length = parseInt(p2sh[1], 16);\n                if (p2sh[2].length === length * 2 && length >= 1 && length <= 75) {\n                    return base58Encode(concat([[coinInfo.p2sh], (\"0x\" + p2sh[2])]));\n                }\n            }\n        }\n        // Bech32\n        if (coinInfo.prefix != null) {\n            const length = bytes[1];\n            // https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki#witness-program\n            let version = bytes[0];\n            if (version === 0x00) {\n                if (length !== 20 && length !== 32) {\n                    version = -1;\n                }\n            }\n            else {\n                version = -1;\n            }\n            if (version >= 0 && bytes.length === 2 + length && length >= 1 && length <= 75) {\n                const words = bech32.toWords(bytes.slice(2));\n                words.unshift(version);\n                return bech32.encode(coinInfo.prefix, words);\n            }\n        }\n        return null;\n    }\n    getAddress(coinType) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (coinType == null) {\n                coinType = 60;\n            }\n            // If Ethereum, use the standard `addr(bytes32)`\n            if (coinType === 60) {\n                try {\n                    // keccak256(\"addr(bytes32)\")\n                    const transaction = {\n                        to: this.address,\n                        data: (\"0x3b3b57de\" + namehash(this.name).substring(2))\n                    };\n                    const hexBytes = yield this.provider.call(transaction);\n                    // No address\n                    if (hexBytes === \"0x\" || hexBytes === HashZero) {\n                        return null;\n                    }\n                    return this.provider.formatter.callAddress(hexBytes);\n                }\n                catch (error) {\n                    if (error.code === Logger.errors.CALL_EXCEPTION) {\n                        return null;\n                    }\n                    throw error;\n                }\n            }\n            // keccak256(\"addr(bytes32,uint256\")\n            const hexBytes = yield this._fetchBytes(\"0xf1cb7e06\", bytes32ify(coinType));\n            // No address\n            if (hexBytes == null || hexBytes === \"0x\") {\n                return null;\n            }\n            // Compute the address\n            const address = this._getAddress(coinType, hexBytes);\n            if (address == null) {\n                logger.throwError(`invalid or unsupported coin data`, Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: `getAddress(${coinType})`,\n                    coinType: coinType,\n                    data: hexBytes\n                });\n            }\n            return address;\n        });\n    }\n    getAvatar() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const linkage = [];\n            try {\n                const avatar = yield this.getText(\"avatar\");\n                if (avatar == null) {\n                    return null;\n                }\n                for (let i = 0; i < matchers.length; i++) {\n                    const match = avatar.match(matchers[i]);\n                    if (match == null) {\n                        continue;\n                    }\n                    switch (match[1]) {\n                        case \"https\":\n                            linkage.push({ type: \"url\", content: avatar });\n                            return { linkage, url: avatar };\n                        case \"data\":\n                            linkage.push({ type: \"data\", content: avatar });\n                            return { linkage, url: avatar };\n                        case \"ipfs\":\n                            linkage.push({ type: \"ipfs\", content: avatar });\n                            return { linkage, url: `https:/\\/gateway.ipfs.io/ipfs/${avatar.substring(7)}` };\n                        case \"erc721\":\n                        case \"erc1155\": {\n                            // Depending on the ERC type, use tokenURI(uint256) or url(uint256)\n                            const selector = (match[1] === \"erc721\") ? \"0xc87b56dd\" : \"0x0e89341c\";\n                            linkage.push({ type: match[1], content: avatar });\n                            // The owner of this name\n                            const owner = (this._resolvedAddress || (yield this.getAddress()));\n                            const comps = (match[2] || \"\").split(\"/\");\n                            if (comps.length !== 2) {\n                                return null;\n                            }\n                            const addr = yield this.provider.formatter.address(comps[0]);\n                            const tokenId = hexZeroPad(BigNumber.from(comps[1]).toHexString(), 32);\n                            // Check that this account owns the token\n                            if (match[1] === \"erc721\") {\n                                // ownerOf(uint256 tokenId)\n                                const tokenOwner = this.provider.formatter.callAddress(yield this.provider.call({\n                                    to: addr, data: hexConcat([\"0x6352211e\", tokenId])\n                                }));\n                                if (owner !== tokenOwner) {\n                                    return null;\n                                }\n                                linkage.push({ type: \"owner\", content: tokenOwner });\n                            }\n                            else if (match[1] === \"erc1155\") {\n                                // balanceOf(address owner, uint256 tokenId)\n                                const balance = BigNumber.from(yield this.provider.call({\n                                    to: addr, data: hexConcat([\"0x00fdd58e\", hexZeroPad(owner, 32), tokenId])\n                                }));\n                                if (balance.isZero()) {\n                                    return null;\n                                }\n                                linkage.push({ type: \"balance\", content: balance.toString() });\n                            }\n                            // Call the token contract for the metadata URL\n                            const tx = {\n                                to: this.provider.formatter.address(comps[0]),\n                                data: hexConcat([selector, tokenId])\n                            };\n                            let metadataUrl = _parseString(yield this.provider.call(tx));\n                            if (metadataUrl == null) {\n                                return null;\n                            }\n                            linkage.push({ type: \"metadata-url\", content: metadataUrl });\n                            // ERC-1155 allows a generic {id} in the URL\n                            if (match[1] === \"erc1155\") {\n                                metadataUrl = metadataUrl.replace(\"{id}\", tokenId.substring(2));\n                            }\n                            // Get the token metadata\n                            const metadata = yield fetchJson(metadataUrl);\n                            // Pull the image URL out\n                            if (!metadata || typeof (metadata.image) !== \"string\" || !metadata.image.match(/^https:\\/\\//i)) {\n                                return null;\n                            }\n                            linkage.push({ type: \"metadata\", content: JSON.stringify(metadata) });\n                            linkage.push({ type: \"url\", content: metadata.image });\n                            return { linkage, url: metadata.image };\n                        }\n                    }\n                }\n            }\n            catch (error) { }\n            return null;\n        });\n    }\n    getContentHash() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // keccak256(\"contenthash()\")\n            const hexBytes = yield this._fetchBytes(\"0xbc1c58d1\");\n            // No contenthash\n            if (hexBytes == null || hexBytes === \"0x\") {\n                return null;\n            }\n            // IPFS (CID: 1, Type: DAG-PB)\n            const ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n            if (ipfs) {\n                const length = parseInt(ipfs[3], 16);\n                if (ipfs[4].length === length * 2) {\n                    return \"ipfs:/\\/\" + Base58.encode(\"0x\" + ipfs[1]);\n                }\n            }\n            // Swarm (CID: 1, Type: swarm-manifest; hash/length hard-coded to keccak256/32)\n            const swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/);\n            if (swarm) {\n                if (swarm[1].length === (32 * 2)) {\n                    return \"bzz:/\\/\" + swarm[1];\n                }\n            }\n            return logger.throwError(`invalid or unsupported content hash data`, Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"getContentHash()\",\n                data: hexBytes\n            });\n        });\n    }\n    getText(key) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // The key encoded as parameter to fetchBytes\n            let keyBytes = toUtf8Bytes(key);\n            // The nodehash consumes the first slot, so the string pointer targets\n            // offset 64, with the length at offset 64 and data starting at offset 96\n            keyBytes = concat([bytes32ify(64), bytes32ify(keyBytes.length), keyBytes]);\n            // Pad to word-size (32 bytes)\n            if ((keyBytes.length % 32) !== 0) {\n                keyBytes = concat([keyBytes, hexZeroPad(\"0x\", 32 - (key.length % 32))]);\n            }\n            const hexBytes = yield this._fetchBytes(\"0x59d1d43c\", hexlify(keyBytes));\n            if (hexBytes == null || hexBytes === \"0x\") {\n                return null;\n            }\n            return toUtf8String(hexBytes);\n        });\n    }\n}\nlet defaultFormatter = null;\nlet nextPollId = 1;\nexport class BaseProvider extends Provider {\n    /**\n     *  ready\n     *\n     *  A Promise<Network> that resolves only once the provider is ready.\n     *\n     *  Sub-classes that call the super with a network without a chainId\n     *  MUST set this. Standard named networks have a known chainId.\n     *\n     */\n    constructor(network) {\n        logger.checkNew(new.target, Provider);\n        super();\n        // Events being listened to\n        this._events = [];\n        this._emitted = { block: -2 };\n        this.formatter = new.target.getFormatter();\n        // If network is any, this Provider allows the underlying\n        // network to change dynamically, and we auto-detect the\n        // current network\n        defineReadOnly(this, \"anyNetwork\", (network === \"any\"));\n        if (this.anyNetwork) {\n            network = this.detectNetwork();\n        }\n        if (network instanceof Promise) {\n            this._networkPromise = network;\n            // Squash any \"unhandled promise\" errors; that do not need to be handled\n            network.catch((error) => { });\n            // Trigger initial network setting (async)\n            this._ready().catch((error) => { });\n        }\n        else {\n            const knownNetwork = getStatic(new.target, \"getNetwork\")(network);\n            if (knownNetwork) {\n                defineReadOnly(this, \"_network\", knownNetwork);\n                this.emit(\"network\", knownNetwork, null);\n            }\n            else {\n                logger.throwArgumentError(\"invalid network\", \"network\", network);\n            }\n        }\n        this._maxInternalBlockNumber = -1024;\n        this._lastBlockNumber = -2;\n        this._pollingInterval = 4000;\n        this._fastQueryDate = 0;\n    }\n    _ready() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._network == null) {\n                let network = null;\n                if (this._networkPromise) {\n                    try {\n                        network = yield this._networkPromise;\n                    }\n                    catch (error) { }\n                }\n                // Try the Provider's network detection (this MUST throw if it cannot)\n                if (network == null) {\n                    network = yield this.detectNetwork();\n                }\n                // This should never happen; every Provider sub-class should have\n                // suggested a network by here (or have thrown).\n                if (!network) {\n                    logger.throwError(\"no network detected\", Logger.errors.UNKNOWN_ERROR, {});\n                }\n                // Possible this call stacked so do not call defineReadOnly again\n                if (this._network == null) {\n                    if (this.anyNetwork) {\n                        this._network = network;\n                    }\n                    else {\n                        defineReadOnly(this, \"_network\", network);\n                    }\n                    this.emit(\"network\", network, null);\n                }\n            }\n            return this._network;\n        });\n    }\n    // This will always return the most recently established network.\n    // For \"any\", this can change (a \"network\" event is emitted before\n    // any change is reflected); otherwise this cannot change\n    get ready() {\n        return poll(() => {\n            return this._ready().then((network) => {\n                return network;\n            }, (error) => {\n                // If the network isn't running yet, we will wait\n                if (error.code === Logger.errors.NETWORK_ERROR && error.event === \"noNetwork\") {\n                    return undefined;\n                }\n                throw error;\n            });\n        });\n    }\n    // @TODO: Remove this and just create a singleton formatter\n    static getFormatter() {\n        if (defaultFormatter == null) {\n            defaultFormatter = new Formatter();\n        }\n        return defaultFormatter;\n    }\n    // @TODO: Remove this and just use getNetwork\n    static getNetwork(network) {\n        return getNetwork((network == null) ? \"homestead\" : network);\n    }\n    // Fetches the blockNumber, but will reuse any result that is less\n    // than maxAge old or has been requested since the last request\n    _getInternalBlockNumber(maxAge) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this._ready();\n            // Allowing stale data up to maxAge old\n            if (maxAge > 0) {\n                // While there are pending internal block requests...\n                while (this._internalBlockNumber) {\n                    // ...\"remember\" which fetch we started with\n                    const internalBlockNumber = this._internalBlockNumber;\n                    try {\n                        // Check the result is not too stale\n                        const result = yield internalBlockNumber;\n                        if ((getTime() - result.respTime) <= maxAge) {\n                            return result.blockNumber;\n                        }\n                        // Too old; fetch a new value\n                        break;\n                    }\n                    catch (error) {\n                        // The fetch rejected; if we are the first to get the\n                        // rejection, drop through so we replace it with a new\n                        // fetch; all others blocked will then get that fetch\n                        // which won't match the one they \"remembered\" and loop\n                        if (this._internalBlockNumber === internalBlockNumber) {\n                            break;\n                        }\n                    }\n                }\n            }\n            const reqTime = getTime();\n            const checkInternalBlockNumber = resolveProperties({\n                blockNumber: this.perform(\"getBlockNumber\", {}),\n                networkError: this.getNetwork().then((network) => (null), (error) => (error))\n            }).then(({ blockNumber, networkError }) => {\n                if (networkError) {\n                    // Unremember this bad internal block number\n                    if (this._internalBlockNumber === checkInternalBlockNumber) {\n                        this._internalBlockNumber = null;\n                    }\n                    throw networkError;\n                }\n                const respTime = getTime();\n                blockNumber = BigNumber.from(blockNumber).toNumber();\n                if (blockNumber < this._maxInternalBlockNumber) {\n                    blockNumber = this._maxInternalBlockNumber;\n                }\n                this._maxInternalBlockNumber = blockNumber;\n                this._setFastBlockNumber(blockNumber); // @TODO: Still need this?\n                return { blockNumber, reqTime, respTime };\n            });\n            this._internalBlockNumber = checkInternalBlockNumber;\n            // Swallow unhandled exceptions; if needed they are handled else where\n            checkInternalBlockNumber.catch((error) => {\n                // Don't null the dead (rejected) fetch, if it has already been updated\n                if (this._internalBlockNumber === checkInternalBlockNumber) {\n                    this._internalBlockNumber = null;\n                }\n            });\n            return (yield checkInternalBlockNumber).blockNumber;\n        });\n    }\n    poll() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const pollId = nextPollId++;\n            // Track all running promises, so we can trigger a post-poll once they are complete\n            const runners = [];\n            let blockNumber = null;\n            try {\n                blockNumber = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2);\n            }\n            catch (error) {\n                this.emit(\"error\", error);\n                return;\n            }\n            this._setFastBlockNumber(blockNumber);\n            // Emit a poll event after we have the latest (fast) block number\n            this.emit(\"poll\", pollId, blockNumber);\n            // If the block has not changed, meh.\n            if (blockNumber === this._lastBlockNumber) {\n                this.emit(\"didPoll\", pollId);\n                return;\n            }\n            // First polling cycle, trigger a \"block\" events\n            if (this._emitted.block === -2) {\n                this._emitted.block = blockNumber - 1;\n            }\n            if (Math.abs((this._emitted.block) - blockNumber) > 1000) {\n                logger.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${blockNumber})`);\n                this.emit(\"error\", logger.makeError(\"network block skew detected\", Logger.errors.NETWORK_ERROR, {\n                    blockNumber: blockNumber,\n                    event: \"blockSkew\",\n                    previousBlockNumber: this._emitted.block\n                }));\n                this.emit(\"block\", blockNumber);\n            }\n            else {\n                // Notify all listener for each block that has passed\n                for (let i = this._emitted.block + 1; i <= blockNumber; i++) {\n                    this.emit(\"block\", i);\n                }\n            }\n            // The emitted block was updated, check for obsolete events\n            if (this._emitted.block !== blockNumber) {\n                this._emitted.block = blockNumber;\n                Object.keys(this._emitted).forEach((key) => {\n                    // The block event does not expire\n                    if (key === \"block\") {\n                        return;\n                    }\n                    // The block we were at when we emitted this event\n                    const eventBlockNumber = this._emitted[key];\n                    // We cannot garbage collect pending transactions or blocks here\n                    // They should be garbage collected by the Provider when setting\n                    // \"pending\" events\n                    if (eventBlockNumber === \"pending\") {\n                        return;\n                    }\n                    // Evict any transaction hashes or block hashes over 12 blocks\n                    // old, since they should not return null anyways\n                    if (blockNumber - eventBlockNumber > 12) {\n                        delete this._emitted[key];\n                    }\n                });\n            }\n            // First polling cycle\n            if (this._lastBlockNumber === -2) {\n                this._lastBlockNumber = blockNumber - 1;\n            }\n            // Find all transaction hashes we are waiting on\n            this._events.forEach((event) => {\n                switch (event.type) {\n                    case \"tx\": {\n                        const hash = event.hash;\n                        let runner = this.getTransactionReceipt(hash).then((receipt) => {\n                            if (!receipt || receipt.blockNumber == null) {\n                                return null;\n                            }\n                            this._emitted[\"t:\" + hash] = receipt.blockNumber;\n                            this.emit(hash, receipt);\n                            return null;\n                        }).catch((error) => { this.emit(\"error\", error); });\n                        runners.push(runner);\n                        break;\n                    }\n                    case \"filter\": {\n                        const filter = event.filter;\n                        filter.fromBlock = this._lastBlockNumber + 1;\n                        filter.toBlock = blockNumber;\n                        const runner = this.getLogs(filter).then((logs) => {\n                            if (logs.length === 0) {\n                                return;\n                            }\n                            logs.forEach((log) => {\n                                this._emitted[\"b:\" + log.blockHash] = log.blockNumber;\n                                this._emitted[\"t:\" + log.transactionHash] = log.blockNumber;\n                                this.emit(filter, log);\n                            });\n                        }).catch((error) => { this.emit(\"error\", error); });\n                        runners.push(runner);\n                        break;\n                    }\n                }\n            });\n            this._lastBlockNumber = blockNumber;\n            // Once all events for this loop have been processed, emit \"didPoll\"\n            Promise.all(runners).then(() => {\n                this.emit(\"didPoll\", pollId);\n            }).catch((error) => { this.emit(\"error\", error); });\n            return;\n        });\n    }\n    // Deprecated; do not use this\n    resetEventsBlock(blockNumber) {\n        this._lastBlockNumber = blockNumber - 1;\n        if (this.polling) {\n            this.poll();\n        }\n    }\n    get network() {\n        return this._network;\n    }\n    // This method should query the network if the underlying network\n    // can change, such as when connected to a JSON-RPC backend\n    detectNetwork() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return logger.throwError(\"provider does not support network detection\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"provider.detectNetwork\"\n            });\n        });\n    }\n    getNetwork() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const network = yield this._ready();\n            // Make sure we are still connected to the same network; this is\n            // only an external call for backends which can have the underlying\n            // network change spontaneously\n            const currentNetwork = yield this.detectNetwork();\n            if (network.chainId !== currentNetwork.chainId) {\n                // We are allowing network changes, things can get complex fast;\n                // make sure you know what you are doing if you use \"any\"\n                if (this.anyNetwork) {\n                    this._network = currentNetwork;\n                    // Reset all internal block number guards and caches\n                    this._lastBlockNumber = -2;\n                    this._fastBlockNumber = null;\n                    this._fastBlockNumberPromise = null;\n                    this._fastQueryDate = 0;\n                    this._emitted.block = -2;\n                    this._maxInternalBlockNumber = -1024;\n                    this._internalBlockNumber = null;\n                    // The \"network\" event MUST happen before this method resolves\n                    // so any events have a chance to unregister, so we stall an\n                    // additional event loop before returning from /this/ call\n                    this.emit(\"network\", currentNetwork, network);\n                    yield stall(0);\n                    return this._network;\n                }\n                const error = logger.makeError(\"underlying network changed\", Logger.errors.NETWORK_ERROR, {\n                    event: \"changed\",\n                    network: network,\n                    detectedNetwork: currentNetwork\n                });\n                this.emit(\"error\", error);\n                throw error;\n            }\n            return network;\n        });\n    }\n    get blockNumber() {\n        this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((blockNumber) => {\n            this._setFastBlockNumber(blockNumber);\n        }, (error) => { });\n        return (this._fastBlockNumber != null) ? this._fastBlockNumber : -1;\n    }\n    get polling() {\n        return (this._poller != null);\n    }\n    set polling(value) {\n        if (value && !this._poller) {\n            this._poller = setInterval(() => { this.poll(); }, this.pollingInterval);\n            if (!this._bootstrapPoll) {\n                this._bootstrapPoll = setTimeout(() => {\n                    this.poll();\n                    // We block additional polls until the polling interval\n                    // is done, to prevent overwhelming the poll function\n                    this._bootstrapPoll = setTimeout(() => {\n                        // If polling was disabled, something may require a poke\n                        // since starting the bootstrap poll and it was disabled\n                        if (!this._poller) {\n                            this.poll();\n                        }\n                        // Clear out the bootstrap so we can do another\n                        this._bootstrapPoll = null;\n                    }, this.pollingInterval);\n                }, 0);\n            }\n        }\n        else if (!value && this._poller) {\n            clearInterval(this._poller);\n            this._poller = null;\n        }\n    }\n    get pollingInterval() {\n        return this._pollingInterval;\n    }\n    set pollingInterval(value) {\n        if (typeof (value) !== \"number\" || value <= 0 || parseInt(String(value)) != value) {\n            throw new Error(\"invalid polling interval\");\n        }\n        this._pollingInterval = value;\n        if (this._poller) {\n            clearInterval(this._poller);\n            this._poller = setInterval(() => { this.poll(); }, this._pollingInterval);\n        }\n    }\n    _getFastBlockNumber() {\n        const now = getTime();\n        // Stale block number, request a newer value\n        if ((now - this._fastQueryDate) > 2 * this._pollingInterval) {\n            this._fastQueryDate = now;\n            this._fastBlockNumberPromise = this.getBlockNumber().then((blockNumber) => {\n                if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {\n                    this._fastBlockNumber = blockNumber;\n                }\n                return this._fastBlockNumber;\n            });\n        }\n        return this._fastBlockNumberPromise;\n    }\n    _setFastBlockNumber(blockNumber) {\n        // Older block, maybe a stale request\n        if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) {\n            return;\n        }\n        // Update the time we updated the blocknumber\n        this._fastQueryDate = getTime();\n        // Newer block number, use  it\n        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {\n            this._fastBlockNumber = blockNumber;\n            this._fastBlockNumberPromise = Promise.resolve(blockNumber);\n        }\n    }\n    waitForTransaction(transactionHash, confirmations, timeout) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this._waitForTransaction(transactionHash, (confirmations == null) ? 1 : confirmations, timeout || 0, null);\n        });\n    }\n    _waitForTransaction(transactionHash, confirmations, timeout, replaceable) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const receipt = yield this.getTransactionReceipt(transactionHash);\n            // Receipt is already good\n            if ((receipt ? receipt.confirmations : 0) >= confirmations) {\n                return receipt;\n            }\n            // Poll until the receipt is good...\n            return new Promise((resolve, reject) => {\n                const cancelFuncs = [];\n                let done = false;\n                const alreadyDone = function () {\n                    if (done) {\n                        return true;\n                    }\n                    done = true;\n                    cancelFuncs.forEach((func) => { func(); });\n                    return false;\n                };\n                const minedHandler = (receipt) => {\n                    if (receipt.confirmations < confirmations) {\n                        return;\n                    }\n                    if (alreadyDone()) {\n                        return;\n                    }\n                    resolve(receipt);\n                };\n                this.on(transactionHash, minedHandler);\n                cancelFuncs.push(() => { this.removeListener(transactionHash, minedHandler); });\n                if (replaceable) {\n                    let lastBlockNumber = replaceable.startBlock;\n                    let scannedBlock = null;\n                    const replaceHandler = (blockNumber) => __awaiter(this, void 0, void 0, function* () {\n                        if (done) {\n                            return;\n                        }\n                        // Wait 1 second; this is only used in the case of a fault, so\n                        // we will trade off a little bit of latency for more consistent\n                        // results and fewer JSON-RPC calls\n                        yield stall(1000);\n                        this.getTransactionCount(replaceable.from).then((nonce) => __awaiter(this, void 0, void 0, function* () {\n                            if (done) {\n                                return;\n                            }\n                            if (nonce <= replaceable.nonce) {\n                                lastBlockNumber = blockNumber;\n                            }\n                            else {\n                                // First check if the transaction was mined\n                                {\n                                    const mined = yield this.getTransaction(transactionHash);\n                                    if (mined && mined.blockNumber != null) {\n                                        return;\n                                    }\n                                }\n                                // First time scanning. We start a little earlier for some\n                                // wiggle room here to handle the eventually consistent nature\n                                // of blockchain (e.g. the getTransactionCount was for a\n                                // different block)\n                                if (scannedBlock == null) {\n                                    scannedBlock = lastBlockNumber - 3;\n                                    if (scannedBlock < replaceable.startBlock) {\n                                        scannedBlock = replaceable.startBlock;\n                                    }\n                                }\n                                while (scannedBlock <= blockNumber) {\n                                    if (done) {\n                                        return;\n                                    }\n                                    const block = yield this.getBlockWithTransactions(scannedBlock);\n                                    for (let ti = 0; ti < block.transactions.length; ti++) {\n                                        const tx = block.transactions[ti];\n                                        // Successfully mined!\n                                        if (tx.hash === transactionHash) {\n                                            return;\n                                        }\n                                        // Matches our transaction from and nonce; its a replacement\n                                        if (tx.from === replaceable.from && tx.nonce === replaceable.nonce) {\n                                            if (done) {\n                                                return;\n                                            }\n                                            // Get the receipt of the replacement\n                                            const receipt = yield this.waitForTransaction(tx.hash, confirmations);\n                                            // Already resolved or rejected (prolly a timeout)\n                                            if (alreadyDone()) {\n                                                return;\n                                            }\n                                            // The reason we were replaced\n                                            let reason = \"replaced\";\n                                            if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {\n                                                reason = \"repriced\";\n                                            }\n                                            else if (tx.data === \"0x\" && tx.from === tx.to && tx.value.isZero()) {\n                                                reason = \"cancelled\";\n                                            }\n                                            // Explain why we were replaced\n                                            reject(logger.makeError(\"transaction was replaced\", Logger.errors.TRANSACTION_REPLACED, {\n                                                cancelled: (reason === \"replaced\" || reason === \"cancelled\"),\n                                                reason,\n                                                replacement: this._wrapTransaction(tx),\n                                                hash: transactionHash,\n                                                receipt\n                                            }));\n                                            return;\n                                        }\n                                    }\n                                    scannedBlock++;\n                                }\n                            }\n                            if (done) {\n                                return;\n                            }\n                            this.once(\"block\", replaceHandler);\n                        }), (error) => {\n                            if (done) {\n                                return;\n                            }\n                            this.once(\"block\", replaceHandler);\n                        });\n                    });\n                    if (done) {\n                        return;\n                    }\n                    this.once(\"block\", replaceHandler);\n                    cancelFuncs.push(() => {\n                        this.removeListener(\"block\", replaceHandler);\n                    });\n                }\n                if (typeof (timeout) === \"number\" && timeout > 0) {\n                    const timer = setTimeout(() => {\n                        if (alreadyDone()) {\n                            return;\n                        }\n                        reject(logger.makeError(\"timeout exceeded\", Logger.errors.TIMEOUT, { timeout: timeout }));\n                    }, timeout);\n                    if (timer.unref) {\n                        timer.unref();\n                    }\n                    cancelFuncs.push(() => { clearTimeout(timer); });\n                }\n            });\n        });\n    }\n    getBlockNumber() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this._getInternalBlockNumber(0);\n        });\n    }\n    getGasPrice() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const result = yield this.perform(\"getGasPrice\", {});\n            try {\n                return BigNumber.from(result);\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"getGasPrice\",\n                    result, error\n                });\n            }\n        });\n    }\n    getBalance(addressOrName, blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag)\n            });\n            const result = yield this.perform(\"getBalance\", params);\n            try {\n                return BigNumber.from(result);\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"getBalance\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    getTransactionCount(addressOrName, blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag)\n            });\n            const result = yield this.perform(\"getTransactionCount\", params);\n            try {\n                return BigNumber.from(result).toNumber();\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"getTransactionCount\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    getCode(addressOrName, blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag)\n            });\n            const result = yield this.perform(\"getCode\", params);\n            try {\n                return hexlify(result);\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"getCode\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    getStorageAt(addressOrName, position, blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag),\n                position: Promise.resolve(position).then((p) => hexValue(p))\n            });\n            const result = yield this.perform(\"getStorageAt\", params);\n            try {\n                return hexlify(result);\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"getStorageAt\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    // This should be called by any subclass wrapping a TransactionResponse\n    _wrapTransaction(tx, hash, startBlock) {\n        if (hash != null && hexDataLength(hash) !== 32) {\n            throw new Error(\"invalid response - sendTransaction\");\n        }\n        const result = tx;\n        // Check the hash we expect is the same as the hash the server reported\n        if (hash != null && tx.hash !== hash) {\n            logger.throwError(\"Transaction hash mismatch from Provider.sendTransaction.\", Logger.errors.UNKNOWN_ERROR, { expectedHash: tx.hash, returnedHash: hash });\n        }\n        result.wait = (confirms, timeout) => __awaiter(this, void 0, void 0, function* () {\n            if (confirms == null) {\n                confirms = 1;\n            }\n            if (timeout == null) {\n                timeout = 0;\n            }\n            // Get the details to detect replacement\n            let replacement = undefined;\n            if (confirms !== 0 && startBlock != null) {\n                replacement = {\n                    data: tx.data,\n                    from: tx.from,\n                    nonce: tx.nonce,\n                    to: tx.to,\n                    value: tx.value,\n                    startBlock\n                };\n            }\n            const receipt = yield this._waitForTransaction(tx.hash, confirms, timeout, replacement);\n            if (receipt == null && confirms === 0) {\n                return null;\n            }\n            // No longer pending, allow the polling loop to garbage collect this\n            this._emitted[\"t:\" + tx.hash] = receipt.blockNumber;\n            if (receipt.status === 0) {\n                logger.throwError(\"transaction failed\", Logger.errors.CALL_EXCEPTION, {\n                    transactionHash: tx.hash,\n                    transaction: tx,\n                    receipt: receipt\n                });\n            }\n            return receipt;\n        });\n        return result;\n    }\n    sendTransaction(signedTransaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const hexTx = yield Promise.resolve(signedTransaction).then(t => hexlify(t));\n            const tx = this.formatter.transaction(signedTransaction);\n            if (tx.confirmations == null) {\n                tx.confirmations = 0;\n            }\n            const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n            try {\n                const hash = yield this.perform(\"sendTransaction\", { signedTransaction: hexTx });\n                return this._wrapTransaction(tx, hash, blockNumber);\n            }\n            catch (error) {\n                error.transaction = tx;\n                error.transactionHash = tx.hash;\n                throw error;\n            }\n        });\n    }\n    _getTransactionRequest(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const values = yield transaction;\n            const tx = {};\n            [\"from\", \"to\"].forEach((key) => {\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v) => (v ? this._getAddress(v) : null));\n            });\n            [\"gasLimit\", \"gasPrice\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"value\"].forEach((key) => {\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v) => (v ? BigNumber.from(v) : null));\n            });\n            [\"type\"].forEach((key) => {\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v) => ((v != null) ? v : null));\n            });\n            if (values.accessList) {\n                tx.accessList = this.formatter.accessList(values.accessList);\n            }\n            [\"data\"].forEach((key) => {\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v) => (v ? hexlify(v) : null));\n            });\n            return this.formatter.transactionRequest(yield resolveProperties(tx));\n        });\n    }\n    _getFilter(filter) {\n        return __awaiter(this, void 0, void 0, function* () {\n            filter = yield filter;\n            const result = {};\n            if (filter.address != null) {\n                result.address = this._getAddress(filter.address);\n            }\n            [\"blockHash\", \"topics\"].forEach((key) => {\n                if (filter[key] == null) {\n                    return;\n                }\n                result[key] = filter[key];\n            });\n            [\"fromBlock\", \"toBlock\"].forEach((key) => {\n                if (filter[key] == null) {\n                    return;\n                }\n                result[key] = this._getBlockTag(filter[key]);\n            });\n            return this.formatter.filter(yield resolveProperties(result));\n        });\n    }\n    call(transaction, blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({\n                transaction: this._getTransactionRequest(transaction),\n                blockTag: this._getBlockTag(blockTag)\n            });\n            const result = yield this.perform(\"call\", params);\n            try {\n                return hexlify(result);\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"call\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    estimateGas(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({\n                transaction: this._getTransactionRequest(transaction)\n            });\n            const result = yield this.perform(\"estimateGas\", params);\n            try {\n                return BigNumber.from(result);\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"estimateGas\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    _getAddress(addressOrName) {\n        return __awaiter(this, void 0, void 0, function* () {\n            addressOrName = yield addressOrName;\n            if (typeof (addressOrName) !== \"string\") {\n                logger.throwArgumentError(\"invalid address or ENS name\", \"name\", addressOrName);\n            }\n            const address = yield this.resolveName(addressOrName);\n            if (address == null) {\n                logger.throwError(\"ENS name not configured\", Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: `resolveName(${JSON.stringify(addressOrName)})`\n                });\n            }\n            return address;\n        });\n    }\n    _getBlock(blockHashOrBlockTag, includeTransactions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            blockHashOrBlockTag = yield blockHashOrBlockTag;\n            // If blockTag is a number (not \"latest\", etc), this is the block number\n            let blockNumber = -128;\n            const params = {\n                includeTransactions: !!includeTransactions\n            };\n            if (isHexString(blockHashOrBlockTag, 32)) {\n                params.blockHash = blockHashOrBlockTag;\n            }\n            else {\n                try {\n                    params.blockTag = yield this._getBlockTag(blockHashOrBlockTag);\n                    if (isHexString(params.blockTag)) {\n                        blockNumber = parseInt(params.blockTag.substring(2), 16);\n                    }\n                }\n                catch (error) {\n                    logger.throwArgumentError(\"invalid block hash or block tag\", \"blockHashOrBlockTag\", blockHashOrBlockTag);\n                }\n            }\n            return poll(() => __awaiter(this, void 0, void 0, function* () {\n                const block = yield this.perform(\"getBlock\", params);\n                // Block was not found\n                if (block == null) {\n                    // For blockhashes, if we didn't say it existed, that blockhash may\n                    // not exist. If we did see it though, perhaps from a log, we know\n                    // it exists, and this node is just not caught up yet.\n                    if (params.blockHash != null) {\n                        if (this._emitted[\"b:\" + params.blockHash] == null) {\n                            return null;\n                        }\n                    }\n                    // For block tags, if we are asking for a future block, we return null\n                    if (params.blockTag != null) {\n                        if (blockNumber > this._emitted.block) {\n                            return null;\n                        }\n                    }\n                    // Retry on the next block\n                    return undefined;\n                }\n                // Add transactions\n                if (includeTransactions) {\n                    let blockNumber = null;\n                    for (let i = 0; i < block.transactions.length; i++) {\n                        const tx = block.transactions[i];\n                        if (tx.blockNumber == null) {\n                            tx.confirmations = 0;\n                        }\n                        else if (tx.confirmations == null) {\n                            if (blockNumber == null) {\n                                blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                            }\n                            // Add the confirmations using the fast block number (pessimistic)\n                            let confirmations = (blockNumber - tx.blockNumber) + 1;\n                            if (confirmations <= 0) {\n                                confirmations = 1;\n                            }\n                            tx.confirmations = confirmations;\n                        }\n                    }\n                    const blockWithTxs = this.formatter.blockWithTransactions(block);\n                    blockWithTxs.transactions = blockWithTxs.transactions.map((tx) => this._wrapTransaction(tx));\n                    return blockWithTxs;\n                }\n                return this.formatter.block(block);\n            }), { oncePoll: this });\n        });\n    }\n    getBlock(blockHashOrBlockTag) {\n        return (this._getBlock(blockHashOrBlockTag, false));\n    }\n    getBlockWithTransactions(blockHashOrBlockTag) {\n        return (this._getBlock(blockHashOrBlockTag, true));\n    }\n    getTransaction(transactionHash) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            transactionHash = yield transactionHash;\n            const params = { transactionHash: this.formatter.hash(transactionHash, true) };\n            return poll(() => __awaiter(this, void 0, void 0, function* () {\n                const result = yield this.perform(\"getTransaction\", params);\n                if (result == null) {\n                    if (this._emitted[\"t:\" + transactionHash] == null) {\n                        return null;\n                    }\n                    return undefined;\n                }\n                const tx = this.formatter.transactionResponse(result);\n                if (tx.blockNumber == null) {\n                    tx.confirmations = 0;\n                }\n                else if (tx.confirmations == null) {\n                    const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                    // Add the confirmations using the fast block number (pessimistic)\n                    let confirmations = (blockNumber - tx.blockNumber) + 1;\n                    if (confirmations <= 0) {\n                        confirmations = 1;\n                    }\n                    tx.confirmations = confirmations;\n                }\n                return this._wrapTransaction(tx);\n            }), { oncePoll: this });\n        });\n    }\n    getTransactionReceipt(transactionHash) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            transactionHash = yield transactionHash;\n            const params = { transactionHash: this.formatter.hash(transactionHash, true) };\n            return poll(() => __awaiter(this, void 0, void 0, function* () {\n                const result = yield this.perform(\"getTransactionReceipt\", params);\n                if (result == null) {\n                    if (this._emitted[\"t:\" + transactionHash] == null) {\n                        return null;\n                    }\n                    return undefined;\n                }\n                // \"geth-etc\" returns receipts before they are ready\n                if (result.blockHash == null) {\n                    return undefined;\n                }\n                const receipt = this.formatter.receipt(result);\n                if (receipt.blockNumber == null) {\n                    receipt.confirmations = 0;\n                }\n                else if (receipt.confirmations == null) {\n                    const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                    // Add the confirmations using the fast block number (pessimistic)\n                    let confirmations = (blockNumber - receipt.blockNumber) + 1;\n                    if (confirmations <= 0) {\n                        confirmations = 1;\n                    }\n                    receipt.confirmations = confirmations;\n                }\n                return receipt;\n            }), { oncePoll: this });\n        });\n    }\n    getLogs(filter) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({ filter: this._getFilter(filter) });\n            const logs = yield this.perform(\"getLogs\", params);\n            logs.forEach((log) => {\n                if (log.removed == null) {\n                    log.removed = false;\n                }\n            });\n            return Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);\n        });\n    }\n    getEtherPrice() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            return this.perform(\"getEtherPrice\", {});\n        });\n    }\n    _getBlockTag(blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            blockTag = yield blockTag;\n            if (typeof (blockTag) === \"number\" && blockTag < 0) {\n                if (blockTag % 1) {\n                    logger.throwArgumentError(\"invalid BlockTag\", \"blockTag\", blockTag);\n                }\n                let blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                blockNumber += blockTag;\n                if (blockNumber < 0) {\n                    blockNumber = 0;\n                }\n                return this.formatter.blockTag(blockNumber);\n            }\n            return this.formatter.blockTag(blockTag);\n        });\n    }\n    getResolver(name) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const address = yield this._getResolver(name);\n                if (address == null) {\n                    return null;\n                }\n                return new Resolver(this, address, name);\n            }\n            catch (error) {\n                if (error.code === Logger.errors.CALL_EXCEPTION) {\n                    return null;\n                }\n                return null;\n            }\n        });\n    }\n    _getResolver(name) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Get the resolver from the blockchain\n            const network = yield this.getNetwork();\n            // No ENS...\n            if (!network.ensAddress) {\n                logger.throwError(\"network does not support ENS\", Logger.errors.UNSUPPORTED_OPERATION, { operation: \"ENS\", network: network.name });\n            }\n            // keccak256(\"resolver(bytes32)\")\n            const transaction = {\n                to: network.ensAddress,\n                data: (\"0x0178b8bf\" + namehash(name).substring(2))\n            };\n            try {\n                return this.formatter.callAddress(yield this.call(transaction));\n            }\n            catch (error) {\n                if (error.code === Logger.errors.CALL_EXCEPTION) {\n                    return null;\n                }\n                throw error;\n            }\n        });\n    }\n    resolveName(name) {\n        return __awaiter(this, void 0, void 0, function* () {\n            name = yield name;\n            // If it is already an address, nothing to resolve\n            try {\n                return Promise.resolve(this.formatter.address(name));\n            }\n            catch (error) {\n                // If is is a hexstring, the address is bad (See #694)\n                if (isHexString(name)) {\n                    throw error;\n                }\n            }\n            if (typeof (name) !== \"string\") {\n                logger.throwArgumentError(\"invalid ENS name\", \"name\", name);\n            }\n            // Get the addr from the resovler\n            const resolver = yield this.getResolver(name);\n            if (!resolver) {\n                return null;\n            }\n            return yield resolver.getAddress();\n        });\n    }\n    lookupAddress(address) {\n        return __awaiter(this, void 0, void 0, function* () {\n            address = yield address;\n            address = this.formatter.address(address);\n            const reverseName = address.substring(2).toLowerCase() + \".addr.reverse\";\n            const resolverAddress = yield this._getResolver(reverseName);\n            if (!resolverAddress) {\n                return null;\n            }\n            // keccak(\"name(bytes32)\")\n            let bytes = arrayify(yield this.call({\n                to: resolverAddress,\n                data: (\"0x691f3431\" + namehash(reverseName).substring(2))\n            }));\n            // Strip off the dynamic string pointer (0x20)\n            if (bytes.length < 32 || !BigNumber.from(bytes.slice(0, 32)).eq(32)) {\n                return null;\n            }\n            bytes = bytes.slice(32);\n            // Not a length-prefixed string\n            if (bytes.length < 32) {\n                return null;\n            }\n            // Get the length of the string (from the length-prefix)\n            const length = BigNumber.from(bytes.slice(0, 32)).toNumber();\n            bytes = bytes.slice(32);\n            // Length longer than available data\n            if (length > bytes.length) {\n                return null;\n            }\n            const name = toUtf8String(bytes.slice(0, length));\n            // Make sure the reverse record matches the foward record\n            const addr = yield this.resolveName(name);\n            if (addr != address) {\n                return null;\n            }\n            return name;\n        });\n    }\n    getAvatar(nameOrAddress) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let resolver = null;\n            if (isHexString(nameOrAddress)) {\n                // Address; reverse lookup\n                const address = this.formatter.address(nameOrAddress);\n                const reverseName = address.substring(2).toLowerCase() + \".addr.reverse\";\n                const resolverAddress = yield this._getResolver(reverseName);\n                if (!resolverAddress) {\n                    return null;\n                }\n                resolver = new Resolver(this, resolverAddress, \"_\", address);\n            }\n            else {\n                // ENS name; forward lookup\n                resolver = yield this.getResolver(nameOrAddress);\n            }\n            const avatar = yield resolver.getAvatar();\n            if (avatar == null) {\n                return null;\n            }\n            return avatar.url;\n        });\n    }\n    perform(method, params) {\n        return logger.throwError(method + \" not implemented\", Logger.errors.NOT_IMPLEMENTED, { operation: method });\n    }\n    _startEvent(event) {\n        this.polling = (this._events.filter((e) => e.pollable()).length > 0);\n    }\n    _stopEvent(event) {\n        this.polling = (this._events.filter((e) => e.pollable()).length > 0);\n    }\n    _addEventListener(eventName, listener, once) {\n        const event = new Event(getEventTag(eventName), listener, once);\n        this._events.push(event);\n        this._startEvent(event);\n        return this;\n    }\n    on(eventName, listener) {\n        return this._addEventListener(eventName, listener, false);\n    }\n    once(eventName, listener) {\n        return this._addEventListener(eventName, listener, true);\n    }\n    emit(eventName, ...args) {\n        let result = false;\n        let stopped = [];\n        let eventTag = getEventTag(eventName);\n        this._events = this._events.filter((event) => {\n            if (event.tag !== eventTag) {\n                return true;\n            }\n            setTimeout(() => {\n                event.listener.apply(this, args);\n            }, 0);\n            result = true;\n            if (event.once) {\n                stopped.push(event);\n                return false;\n            }\n            return true;\n        });\n        stopped.forEach((event) => { this._stopEvent(event); });\n        return result;\n    }\n    listenerCount(eventName) {\n        if (!eventName) {\n            return this._events.length;\n        }\n        let eventTag = getEventTag(eventName);\n        return this._events.filter((event) => {\n            return (event.tag === eventTag);\n        }).length;\n    }\n    listeners(eventName) {\n        if (eventName == null) {\n            return this._events.map((event) => event.listener);\n        }\n        let eventTag = getEventTag(eventName);\n        return this._events\n            .filter((event) => (event.tag === eventTag))\n            .map((event) => event.listener);\n    }\n    off(eventName, listener) {\n        if (listener == null) {\n            return this.removeAllListeners(eventName);\n        }\n        const stopped = [];\n        let found = false;\n        let eventTag = getEventTag(eventName);\n        this._events = this._events.filter((event) => {\n            if (event.tag !== eventTag || event.listener != listener) {\n                return true;\n            }\n            if (found) {\n                return true;\n            }\n            found = true;\n            stopped.push(event);\n            return false;\n        });\n        stopped.forEach((event) => { this._stopEvent(event); });\n        return this;\n    }\n    removeAllListeners(eventName) {\n        let stopped = [];\n        if (eventName == null) {\n            stopped = this._events;\n            this._events = [];\n        }\n        else {\n            const eventTag = getEventTag(eventName);\n            this._events = this._events.filter((event) => {\n                if (event.tag !== eventTag) {\n                    return true;\n                }\n                stopped.push(event);\n                return false;\n            });\n        }\n        stopped.forEach((event) => { this._stopEvent(event); });\n        return this;\n    }\n}\n//# sourceMappingURL=base-provider.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Signer } from \"@ethersproject/abstract-signer\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { hexlify, hexValue, isHexString } from \"@ethersproject/bytes\";\nimport { _TypedDataEncoder } from \"@ethersproject/hash\";\nimport { checkProperties, deepCopy, defineReadOnly, getStatic, resolveProperties, shallowCopy } from \"@ethersproject/properties\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\nimport { accessListify } from \"@ethersproject/transactions\";\nimport { fetchJson, poll } from \"@ethersproject/web\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { BaseProvider } from \"./base-provider\";\nconst errorGas = [\"call\", \"estimateGas\"];\nfunction checkError(method, error, params) {\n    // Undo the \"convenience\" some nodes are attempting to prevent backwards\n    // incompatibility; maybe for v6 consider forwarding reverts as errors\n    if (method === \"call\" && error.code === Logger.errors.SERVER_ERROR) {\n        const e = error.error;\n        if (e && e.message.match(\"reverted\") && isHexString(e.data)) {\n            return e.data;\n        }\n        logger.throwError(\"missing revert data in call exception\", Logger.errors.CALL_EXCEPTION, {\n            error, data: \"0x\"\n        });\n    }\n    let message = error.message;\n    if (error.code === Logger.errors.SERVER_ERROR && error.error && typeof (error.error.message) === \"string\") {\n        message = error.error.message;\n    }\n    else if (typeof (error.body) === \"string\") {\n        message = error.body;\n    }\n    else if (typeof (error.responseText) === \"string\") {\n        message = error.responseText;\n    }\n    message = (message || \"\").toLowerCase();\n    const transaction = params.transaction || params.signedTransaction;\n    // \"insufficient funds for gas * price + value + cost(data)\"\n    if (message.match(/insufficient funds|base fee exceeds gas limit/)) {\n        logger.throwError(\"insufficient funds for intrinsic transaction cost\", Logger.errors.INSUFFICIENT_FUNDS, {\n            error, method, transaction\n        });\n    }\n    // \"nonce too low\"\n    if (message.match(/nonce too low/)) {\n        logger.throwError(\"nonce has already been used\", Logger.errors.NONCE_EXPIRED, {\n            error, method, transaction\n        });\n    }\n    // \"replacement transaction underpriced\"\n    if (message.match(/replacement transaction underpriced/)) {\n        logger.throwError(\"replacement fee too low\", Logger.errors.REPLACEMENT_UNDERPRICED, {\n            error, method, transaction\n        });\n    }\n    // \"replacement transaction underpriced\"\n    if (message.match(/only replay-protected/)) {\n        logger.throwError(\"legacy pre-eip-155 transactions not supported\", Logger.errors.UNSUPPORTED_OPERATION, {\n            error, method, transaction\n        });\n    }\n    if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted/)) {\n        logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n            error, method, transaction\n        });\n    }\n    throw error;\n}\nfunction timer(timeout) {\n    return new Promise(function (resolve) {\n        setTimeout(resolve, timeout);\n    });\n}\nfunction getResult(payload) {\n    if (payload.error) {\n        // @TODO: not any\n        const error = new Error(payload.error.message);\n        error.code = payload.error.code;\n        error.data = payload.error.data;\n        throw error;\n    }\n    return payload.result;\n}\nfunction getLowerCase(value) {\n    if (value) {\n        return value.toLowerCase();\n    }\n    return value;\n}\nconst _constructorGuard = {};\nexport class JsonRpcSigner extends Signer {\n    constructor(constructorGuard, provider, addressOrIndex) {\n        logger.checkNew(new.target, JsonRpcSigner);\n        super();\n        if (constructorGuard !== _constructorGuard) {\n            throw new Error(\"do not call the JsonRpcSigner constructor directly; use provider.getSigner\");\n        }\n        defineReadOnly(this, \"provider\", provider);\n        if (addressOrIndex == null) {\n            addressOrIndex = 0;\n        }\n        if (typeof (addressOrIndex) === \"string\") {\n            defineReadOnly(this, \"_address\", this.provider.formatter.address(addressOrIndex));\n            defineReadOnly(this, \"_index\", null);\n        }\n        else if (typeof (addressOrIndex) === \"number\") {\n            defineReadOnly(this, \"_index\", addressOrIndex);\n            defineReadOnly(this, \"_address\", null);\n        }\n        else {\n            logger.throwArgumentError(\"invalid address or index\", \"addressOrIndex\", addressOrIndex);\n        }\n    }\n    connect(provider) {\n        return logger.throwError(\"cannot alter JSON-RPC Signer connection\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"connect\"\n        });\n    }\n    connectUnchecked() {\n        return new UncheckedJsonRpcSigner(_constructorGuard, this.provider, this._address || this._index);\n    }\n    getAddress() {\n        if (this._address) {\n            return Promise.resolve(this._address);\n        }\n        return this.provider.send(\"eth_accounts\", []).then((accounts) => {\n            if (accounts.length <= this._index) {\n                logger.throwError(\"unknown account #\" + this._index, Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"getAddress\"\n                });\n            }\n            return this.provider.formatter.address(accounts[this._index]);\n        });\n    }\n    sendUncheckedTransaction(transaction) {\n        transaction = shallowCopy(transaction);\n        const fromAddress = this.getAddress().then((address) => {\n            if (address) {\n                address = address.toLowerCase();\n            }\n            return address;\n        });\n        // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user\n        // wishes to use this, it is easy to specify explicitly, otherwise\n        // we look it up for them.\n        if (transaction.gasLimit == null) {\n            const estimate = shallowCopy(transaction);\n            estimate.from = fromAddress;\n            transaction.gasLimit = this.provider.estimateGas(estimate);\n        }\n        if (transaction.to != null) {\n            transaction.to = Promise.resolve(transaction.to).then((to) => __awaiter(this, void 0, void 0, function* () {\n                if (to == null) {\n                    return null;\n                }\n                const address = yield this.provider.resolveName(to);\n                if (address == null) {\n                    logger.throwArgumentError(\"provided ENS name resolves to null\", \"tx.to\", to);\n                }\n                return address;\n            }));\n        }\n        return resolveProperties({\n            tx: resolveProperties(transaction),\n            sender: fromAddress\n        }).then(({ tx, sender }) => {\n            if (tx.from != null) {\n                if (tx.from.toLowerCase() !== sender) {\n                    logger.throwArgumentError(\"from address mismatch\", \"transaction\", transaction);\n                }\n            }\n            else {\n                tx.from = sender;\n            }\n            const hexTx = this.provider.constructor.hexlifyTransaction(tx, { from: true });\n            return this.provider.send(\"eth_sendTransaction\", [hexTx]).then((hash) => {\n                return hash;\n            }, (error) => {\n                return checkError(\"sendTransaction\", error, hexTx);\n            });\n        });\n    }\n    signTransaction(transaction) {\n        return logger.throwError(\"signing transactions is unsupported\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"signTransaction\"\n        });\n    }\n    sendTransaction(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // This cannot be mined any earlier than any recent block\n            const blockNumber = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval);\n            // Send the transaction\n            const hash = yield this.sendUncheckedTransaction(transaction);\n            try {\n                // Unfortunately, JSON-RPC only provides and opaque transaction hash\n                // for a response, and we need the actual transaction, so we poll\n                // for it; it should show up very quickly\n                return yield poll(() => __awaiter(this, void 0, void 0, function* () {\n                    const tx = yield this.provider.getTransaction(hash);\n                    if (tx === null) {\n                        return undefined;\n                    }\n                    return this.provider._wrapTransaction(tx, hash, blockNumber);\n                }), { oncePoll: this.provider });\n            }\n            catch (error) {\n                error.transactionHash = hash;\n                throw error;\n            }\n        });\n    }\n    signMessage(message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = ((typeof (message) === \"string\") ? toUtf8Bytes(message) : message);\n            const address = yield this.getAddress();\n            return yield this.provider.send(\"personal_sign\", [hexlify(data), address.toLowerCase()]);\n        });\n    }\n    _legacySignMessage(message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = ((typeof (message) === \"string\") ? toUtf8Bytes(message) : message);\n            const address = yield this.getAddress();\n            // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign\n            return yield this.provider.send(\"eth_sign\", [address.toLowerCase(), hexlify(data)]);\n        });\n    }\n    _signTypedData(domain, types, value) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Populate any ENS names (in-place)\n            const populated = yield _TypedDataEncoder.resolveNames(domain, types, value, (name) => {\n                return this.provider.resolveName(name);\n            });\n            const address = yield this.getAddress();\n            return yield this.provider.send(\"eth_signTypedData_v4\", [\n                address.toLowerCase(),\n                JSON.stringify(_TypedDataEncoder.getPayload(populated.domain, types, populated.value))\n            ]);\n        });\n    }\n    unlock(password) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const provider = this.provider;\n            const address = yield this.getAddress();\n            return provider.send(\"personal_unlockAccount\", [address.toLowerCase(), password, null]);\n        });\n    }\n}\nclass UncheckedJsonRpcSigner extends JsonRpcSigner {\n    sendTransaction(transaction) {\n        return this.sendUncheckedTransaction(transaction).then((hash) => {\n            return {\n                hash: hash,\n                nonce: null,\n                gasLimit: null,\n                gasPrice: null,\n                data: null,\n                value: null,\n                chainId: null,\n                confirmations: 0,\n                from: null,\n                wait: (confirmations) => { return this.provider.waitForTransaction(hash, confirmations); }\n            };\n        });\n    }\n}\nconst allowedTransactionKeys = {\n    chainId: true, data: true, gasLimit: true, gasPrice: true, nonce: true, to: true, value: true,\n    type: true, accessList: true,\n    maxFeePerGas: true, maxPriorityFeePerGas: true\n};\nexport class JsonRpcProvider extends BaseProvider {\n    constructor(url, network) {\n        logger.checkNew(new.target, JsonRpcProvider);\n        let networkOrReady = network;\n        // The network is unknown, query the JSON-RPC for it\n        if (networkOrReady == null) {\n            networkOrReady = new Promise((resolve, reject) => {\n                setTimeout(() => {\n                    this.detectNetwork().then((network) => {\n                        resolve(network);\n                    }, (error) => {\n                        reject(error);\n                    });\n                }, 0);\n            });\n        }\n        super(networkOrReady);\n        // Default URL\n        if (!url) {\n            url = getStatic(this.constructor, \"defaultUrl\")();\n        }\n        if (typeof (url) === \"string\") {\n            defineReadOnly(this, \"connection\", Object.freeze({\n                url: url\n            }));\n        }\n        else {\n            defineReadOnly(this, \"connection\", Object.freeze(shallowCopy(url)));\n        }\n        this._nextId = 42;\n    }\n    get _cache() {\n        if (this._eventLoopCache == null) {\n            this._eventLoopCache = {};\n        }\n        return this._eventLoopCache;\n    }\n    static defaultUrl() {\n        return \"http:/\\/localhost:8545\";\n    }\n    detectNetwork() {\n        if (!this._cache[\"detectNetwork\"]) {\n            this._cache[\"detectNetwork\"] = this._uncachedDetectNetwork();\n            // Clear this cache at the beginning of the next event loop\n            setTimeout(() => {\n                this._cache[\"detectNetwork\"] = null;\n            }, 0);\n        }\n        return this._cache[\"detectNetwork\"];\n    }\n    _uncachedDetectNetwork() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield timer(0);\n            let chainId = null;\n            try {\n                chainId = yield this.send(\"eth_chainId\", []);\n            }\n            catch (error) {\n                try {\n                    chainId = yield this.send(\"net_version\", []);\n                }\n                catch (error) { }\n            }\n            if (chainId != null) {\n                const getNetwork = getStatic(this.constructor, \"getNetwork\");\n                try {\n                    return getNetwork(BigNumber.from(chainId).toNumber());\n                }\n                catch (error) {\n                    return logger.throwError(\"could not detect network\", Logger.errors.NETWORK_ERROR, {\n                        chainId: chainId,\n                        event: \"invalidNetwork\",\n                        serverError: error\n                    });\n                }\n            }\n            return logger.throwError(\"could not detect network\", Logger.errors.NETWORK_ERROR, {\n                event: \"noNetwork\"\n            });\n        });\n    }\n    getSigner(addressOrIndex) {\n        return new JsonRpcSigner(_constructorGuard, this, addressOrIndex);\n    }\n    getUncheckedSigner(addressOrIndex) {\n        return this.getSigner(addressOrIndex).connectUnchecked();\n    }\n    listAccounts() {\n        return this.send(\"eth_accounts\", []).then((accounts) => {\n            return accounts.map((a) => this.formatter.address(a));\n        });\n    }\n    send(method, params) {\n        const request = {\n            method: method,\n            params: params,\n            id: (this._nextId++),\n            jsonrpc: \"2.0\"\n        };\n        this.emit(\"debug\", {\n            action: \"request\",\n            request: deepCopy(request),\n            provider: this\n        });\n        // We can expand this in the future to any call, but for now these\n        // are the biggest wins and do not require any serializing parameters.\n        const cache = ([\"eth_chainId\", \"eth_blockNumber\"].indexOf(method) >= 0);\n        if (cache && this._cache[method]) {\n            return this._cache[method];\n        }\n        const result = fetchJson(this.connection, JSON.stringify(request), getResult).then((result) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                request: request,\n                response: result,\n                provider: this\n            });\n            return result;\n        }, (error) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                error: error,\n                request: request,\n                provider: this\n            });\n            throw error;\n        });\n        // Cache the fetch, but clear it on the next event loop\n        if (cache) {\n            this._cache[method] = result;\n            setTimeout(() => {\n                this._cache[method] = null;\n            }, 0);\n        }\n        return result;\n    }\n    prepareRequest(method, params) {\n        switch (method) {\n            case \"getBlockNumber\":\n                return [\"eth_blockNumber\", []];\n            case \"getGasPrice\":\n                return [\"eth_gasPrice\", []];\n            case \"getBalance\":\n                return [\"eth_getBalance\", [getLowerCase(params.address), params.blockTag]];\n            case \"getTransactionCount\":\n                return [\"eth_getTransactionCount\", [getLowerCase(params.address), params.blockTag]];\n            case \"getCode\":\n                return [\"eth_getCode\", [getLowerCase(params.address), params.blockTag]];\n            case \"getStorageAt\":\n                return [\"eth_getStorageAt\", [getLowerCase(params.address), params.position, params.blockTag]];\n            case \"sendTransaction\":\n                return [\"eth_sendRawTransaction\", [params.signedTransaction]];\n            case \"getBlock\":\n                if (params.blockTag) {\n                    return [\"eth_getBlockByNumber\", [params.blockTag, !!params.includeTransactions]];\n                }\n                else if (params.blockHash) {\n                    return [\"eth_getBlockByHash\", [params.blockHash, !!params.includeTransactions]];\n                }\n                return null;\n            case \"getTransaction\":\n                return [\"eth_getTransactionByHash\", [params.transactionHash]];\n            case \"getTransactionReceipt\":\n                return [\"eth_getTransactionReceipt\", [params.transactionHash]];\n            case \"call\": {\n                const hexlifyTransaction = getStatic(this.constructor, \"hexlifyTransaction\");\n                return [\"eth_call\", [hexlifyTransaction(params.transaction, { from: true }), params.blockTag]];\n            }\n            case \"estimateGas\": {\n                const hexlifyTransaction = getStatic(this.constructor, \"hexlifyTransaction\");\n                return [\"eth_estimateGas\", [hexlifyTransaction(params.transaction, { from: true })]];\n            }\n            case \"getLogs\":\n                if (params.filter && params.filter.address != null) {\n                    params.filter.address = getLowerCase(params.filter.address);\n                }\n                return [\"eth_getLogs\", [params.filter]];\n            default:\n                break;\n        }\n        return null;\n    }\n    perform(method, params) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Legacy networks do not like the type field being passed along (which\n            // is fair), so we delete type if it is 0 and a non-EIP-1559 network\n            if (method === \"call\" || method === \"estimateGas\") {\n                const tx = params.transaction;\n                if (tx && tx.type != null && BigNumber.from(tx.type).isZero()) {\n                    // If there are no EIP-1559 properties, it might be non-EIP-a559\n                    if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {\n                        const feeData = yield this.getFeeData();\n                        if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {\n                            // Network doesn't know about EIP-1559 (and hence type)\n                            params = shallowCopy(params);\n                            params.transaction = shallowCopy(tx);\n                            delete params.transaction.type;\n                        }\n                    }\n                }\n            }\n            const args = this.prepareRequest(method, params);\n            if (args == null) {\n                logger.throwError(method + \" not implemented\", Logger.errors.NOT_IMPLEMENTED, { operation: method });\n            }\n            try {\n                return yield this.send(args[0], args[1]);\n            }\n            catch (error) {\n                return checkError(method, error, params);\n            }\n        });\n    }\n    _startEvent(event) {\n        if (event.tag === \"pending\") {\n            this._startPending();\n        }\n        super._startEvent(event);\n    }\n    _startPending() {\n        if (this._pendingFilter != null) {\n            return;\n        }\n        const self = this;\n        const pendingFilter = this.send(\"eth_newPendingTransactionFilter\", []);\n        this._pendingFilter = pendingFilter;\n        pendingFilter.then(function (filterId) {\n            function poll() {\n                self.send(\"eth_getFilterChanges\", [filterId]).then(function (hashes) {\n                    if (self._pendingFilter != pendingFilter) {\n                        return null;\n                    }\n                    let seq = Promise.resolve();\n                    hashes.forEach(function (hash) {\n                        // @TODO: This should be garbage collected at some point... How? When?\n                        self._emitted[\"t:\" + hash.toLowerCase()] = \"pending\";\n                        seq = seq.then(function () {\n                            return self.getTransaction(hash).then(function (tx) {\n                                self.emit(\"pending\", tx);\n                                return null;\n                            });\n                        });\n                    });\n                    return seq.then(function () {\n                        return timer(1000);\n                    });\n                }).then(function () {\n                    if (self._pendingFilter != pendingFilter) {\n                        self.send(\"eth_uninstallFilter\", [filterId]);\n                        return;\n                    }\n                    setTimeout(function () { poll(); }, 0);\n                    return null;\n                }).catch((error) => { });\n            }\n            poll();\n            return filterId;\n        }).catch((error) => { });\n    }\n    _stopEvent(event) {\n        if (event.tag === \"pending\" && this.listenerCount(\"pending\") === 0) {\n            this._pendingFilter = null;\n        }\n        super._stopEvent(event);\n    }\n    // Convert an ethers.js transaction into a JSON-RPC transaction\n    //  - gasLimit => gas\n    //  - All values hexlified\n    //  - All numeric values zero-striped\n    //  - All addresses are lowercased\n    // NOTE: This allows a TransactionRequest, but all values should be resolved\n    //       before this is called\n    // @TODO: This will likely be removed in future versions and prepareRequest\n    //        will be the preferred method for this.\n    static hexlifyTransaction(transaction, allowExtra) {\n        // Check only allowed properties are given\n        const allowed = shallowCopy(allowedTransactionKeys);\n        if (allowExtra) {\n            for (const key in allowExtra) {\n                if (allowExtra[key]) {\n                    allowed[key] = true;\n                }\n            }\n        }\n        checkProperties(transaction, allowed);\n        const result = {};\n        // Some nodes (INFURA ropsten; INFURA mainnet is fine) do not like leading zeros.\n        [\"gasLimit\", \"gasPrice\", \"type\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"value\"].forEach(function (key) {\n            if (transaction[key] == null) {\n                return;\n            }\n            const value = hexValue(transaction[key]);\n            if (key === \"gasLimit\") {\n                key = \"gas\";\n            }\n            result[key] = value;\n        });\n        [\"from\", \"to\", \"data\"].forEach(function (key) {\n            if (transaction[key] == null) {\n                return;\n            }\n            result[key] = hexlify(transaction[key]);\n        });\n        if (transaction.accessList) {\n            result[\"accessList\"] = accessListify(transaction.accessList);\n        }\n        return result;\n    }\n}\n//# sourceMappingURL=json-rpc-provider.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { defineReadOnly, getStatic } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\n// A StaticJsonRpcProvider is useful when you *know* for certain that\n// the backend will never change, as it never calls eth_chainId to\n// verify its backend. However, if the backend does change, the effects\n// are undefined and may include:\n// - inconsistent results\n// - locking up the UI\n// - block skew warnings\n// - wrong results\n// If the network is not explicit (i.e. auto-detection is expected), the\n// node MUST be running and available to respond to requests BEFORE this\n// is instantiated.\nexport class StaticJsonRpcProvider extends JsonRpcProvider {\n    detectNetwork() {\n        const _super = Object.create(null, {\n            detectNetwork: { get: () => super.detectNetwork }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            let network = this.network;\n            if (network == null) {\n                network = yield _super.detectNetwork.call(this);\n                if (!network) {\n                    logger.throwError(\"no network detected\", Logger.errors.UNKNOWN_ERROR, {});\n                }\n                // If still not set, set it\n                if (this._network == null) {\n                    // A static network does not support \"any\"\n                    defineReadOnly(this, \"_network\", network);\n                    this.emit(\"network\", network, null);\n                }\n            }\n            return network;\n        });\n    }\n}\nexport class UrlJsonRpcProvider extends StaticJsonRpcProvider {\n    constructor(network, apiKey) {\n        logger.checkAbstract(new.target, UrlJsonRpcProvider);\n        // Normalize the Network and API Key\n        network = getStatic(new.target, \"getNetwork\")(network);\n        apiKey = getStatic(new.target, \"getApiKey\")(apiKey);\n        const connection = getStatic(new.target, \"getUrl\")(network, apiKey);\n        super(connection, network);\n        if (typeof (apiKey) === \"string\") {\n            defineReadOnly(this, \"apiKey\", apiKey);\n        }\n        else if (apiKey != null) {\n            Object.keys(apiKey).forEach((key) => {\n                defineReadOnly(this, key, apiKey[key]);\n            });\n        }\n    }\n    _startPending() {\n        logger.warn(\"WARNING: API provider does not support pending filters\");\n    }\n    isCommunityResource() {\n        return false;\n    }\n    getSigner(address) {\n        return logger.throwError(\"API provider does not support signing\", Logger.errors.UNSUPPORTED_OPERATION, { operation: \"getSigner\" });\n    }\n    listAccounts() {\n        return Promise.resolve([]);\n    }\n    // Return a defaultApiKey if null, otherwise validate the API key\n    static getApiKey(apiKey) {\n        return apiKey;\n    }\n    // Returns the url or connection for the given network and API key. The\n    // API key will have been sanitized by the getApiKey first, so any validation\n    // or transformations can be done there.\n    static getUrl(network, apiKey) {\n        return logger.throwError(\"not implemented; sub-classes must override getUrl\", Logger.errors.NOT_IMPLEMENTED, {\n            operation: \"getUrl\"\n        });\n    }\n}\n//# sourceMappingURL=url-json-rpc-provider.js.map","\"use strict\";\nimport { Provider } from \"@ethersproject/abstract-provider\";\nimport { getNetwork } from \"@ethersproject/networks\";\nimport { BaseProvider, Resolver } from \"./base-provider\";\nimport { AlchemyProvider, AlchemyWebSocketProvider } from \"./alchemy-provider\";\nimport { CloudflareProvider } from \"./cloudflare-provider\";\nimport { EtherscanProvider } from \"./etherscan-provider\";\nimport { FallbackProvider } from \"./fallback-provider\";\nimport { IpcProvider } from \"./ipc-provider\";\nimport { InfuraProvider, InfuraWebSocketProvider } from \"./infura-provider\";\nimport { JsonRpcProvider, JsonRpcSigner } from \"./json-rpc-provider\";\nimport { JsonRpcBatchProvider } from \"./json-rpc-batch-provider\";\nimport { NodesmithProvider } from \"./nodesmith-provider\";\nimport { PocketProvider } from \"./pocket-provider\";\nimport { StaticJsonRpcProvider, UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\nimport { Web3Provider } from \"./web3-provider\";\nimport { WebSocketProvider } from \"./websocket-provider\";\nimport { Formatter, isCommunityResourcable, isCommunityResource, showThrottleMessage } from \"./formatter\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n////////////////////////\n// Helper Functions\nfunction getDefaultProvider(network, options) {\n    if (network == null) {\n        network = \"homestead\";\n    }\n    // If passed a URL, figure out the right type of provider based on the scheme\n    if (typeof (network) === \"string\") {\n        // @TODO: Add support for IpcProvider; maybe if it ends in \".ipc\"?\n        // Handle http and ws (and their secure variants)\n        const match = network.match(/^(ws|http)s?:/i);\n        if (match) {\n            switch (match[1]) {\n                case \"http\":\n                    return new JsonRpcProvider(network);\n                case \"ws\":\n                    return new WebSocketProvider(network);\n                default:\n                    logger.throwArgumentError(\"unsupported URL scheme\", \"network\", network);\n            }\n        }\n    }\n    const n = getNetwork(network);\n    if (!n || !n._defaultProvider) {\n        logger.throwError(\"unsupported getDefaultProvider network\", Logger.errors.NETWORK_ERROR, {\n            operation: \"getDefaultProvider\",\n            network: network\n        });\n    }\n    return n._defaultProvider({\n        FallbackProvider,\n        AlchemyProvider,\n        CloudflareProvider,\n        EtherscanProvider,\n        InfuraProvider,\n        JsonRpcProvider,\n        NodesmithProvider,\n        PocketProvider,\n        Web3Provider,\n        IpcProvider,\n    }, options);\n}\n////////////////////////\n// Exports\nexport { \n// Abstract Providers (or Abstract-ish)\nProvider, BaseProvider, Resolver, UrlJsonRpcProvider, \n///////////////////////\n// Concrete Providers\nFallbackProvider, AlchemyProvider, AlchemyWebSocketProvider, CloudflareProvider, EtherscanProvider, InfuraProvider, InfuraWebSocketProvider, JsonRpcProvider, JsonRpcBatchProvider, NodesmithProvider, PocketProvider, StaticJsonRpcProvider, Web3Provider, WebSocketProvider, IpcProvider, \n///////////////////////\n// Signer\nJsonRpcSigner, \n///////////////////////\n// Functions\ngetDefaultProvider, getNetwork, isCommunityResource, isCommunityResourcable, showThrottleMessage, \n///////////////////////\n// Objects\nFormatter };\n//# sourceMappingURL=index.js.map"],"names":["version","logger","Formatter","constructor","checkNew","this","formats","getDefaultFormats","address","bind","bigNumber","blockTag","data","hash","hex","number","type","transaction","accessList","allowNull","blockHash","blockNumber","transactionIndex","confirmations","from","gasPrice","maxPriorityFeePerGas","maxFeePerGas","gasLimit","to","value","nonce","r","uint256","s","v","creates","raw","transactionRequest","receiptLog","transactionHash","topics","arrayOf","logIndex","receipt","contractAddress","root","gasUsed","logsBloom","logs","cumulativeGasUsed","effectiveGasPrice","status","block","parentHash","timestamp","difficulty","miner","extraData","transactions","baseFeePerGas","blockWithTransactions","transactionResponse","filter","fromBlock","undefined","toBlock","filterLog","removed","boolean","allowFalsish","toNumber","toLowerCase","Error","strict","substring","isHexString","throwArgumentError","result","length","callAddress","hexDataSlice","hexValue","hexDataLength","error","hexZeroPad","_block","format","author","_difficulty","check","gas","isZero","input","chainId","networkId","parseInt","replace","byzantium","Array","isArray","map","static","object","key","checkKey","checkValue","nullValue","replaceValue","array","forEach","push","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","step","next","e","rejected","done","then","apply","checkTopic","topic","serializeTopics","slice","pop","unique","sorted","Object","keys","sort","join","getEventTag","eventName","indexOf","isForkEvent","warn","getTime","Date","stall","duration","setTimeout","PollableEvents","Event","tag","listener","once","event","split","comps","pollable","coinInfos","symbol","p2pkh","p2sh","prefix","ilk","bytes32ify","toHexString","base58Encode","encode","concat","sha2","matchers","RegExp","_parseString","_parseBytes","offset","Resolver","provider","name","resolvedAddress","formatter","_fetchBytes","selector","parameters","tx","hexConcat","namehash","call","code","errors","CALL_EXCEPTION","_getAddress","coinType","hexBytes","coinInfo","String","throwError","UNSUPPORTED_OPERATION","operation","bytes","arrayify","match","words","unshift","getAddress","getAvatar","linkage","avatar","getText","i","content","url","owner","_resolvedAddress","addr","tokenId","tokenOwner","balance","toString","metadataUrl","metadata","image","JSON","stringify","getContentHash","ipfs","swarm","keyBytes","hexlify","defaultFormatter","nextPollId","BaseProvider","network","super","_events","_emitted","getFormatter","anyNetwork","detectNetwork","_networkPromise","catch","_ready","knownNetwork","emit","_maxInternalBlockNumber","_lastBlockNumber","_pollingInterval","_fastQueryDate","_network","UNKNOWN_ERROR","ready","NETWORK_ERROR","_getInternalBlockNumber","maxAge","_internalBlockNumber","internalBlockNumber","respTime","reqTime","checkInternalBlockNumber","perform","networkError","getNetwork","_setFastBlockNumber","poll","pollId","runners","pollingInterval","Math","abs","makeError","previousBlockNumber","eventBlockNumber","runner","getTransactionReceipt","getLogs","log","all","resetEventsBlock","polling","currentNetwork","_fastBlockNumber","_fastBlockNumberPromise","detectedNetwork","_poller","setInterval","_bootstrapPoll","clearInterval","_getFastBlockNumber","now","getBlockNumber","waitForTransaction","timeout","_waitForTransaction","replaceable","cancelFuncs","alreadyDone","func","minedHandler","on","removeListener","lastBlockNumber","startBlock","scannedBlock","replaceHandler","getTransactionCount","mined","getTransaction","getBlockWithTransactions","ti","reason","eq","TRANSACTION_REPLACED","cancelled","replacement","_wrapTransaction","timer","TIMEOUT","unref","clearTimeout","getGasPrice","SERVER_ERROR","method","getBalance","addressOrName","params","_getBlockTag","getCode","getStorageAt","position","p","expectedHash","returnedHash","wait","confirms","sendTransaction","signedTransaction","hexTx","t","_getTransactionRequest","values","_getFilter","estimateGas","resolveName","_getBlock","blockHashOrBlockTag","includeTransactions","blockWithTxs","oncePoll","getBlock","getEtherPrice","getResolver","_getResolver","ensAddress","resolver","lookupAddress","reverseName","resolverAddress","nameOrAddress","NOT_IMPLEMENTED","_startEvent","_stopEvent","_addEventListener","args","stopped","eventTag","listenerCount","listeners","off","removeAllListeners","found","errorGas","checkError","message","body","responseText","INSUFFICIENT_FUNDS","NONCE_EXPIRED","REPLACEMENT_UNDERPRICED","UNPREDICTABLE_GAS_LIMIT","getResult","payload","getLowerCase","_constructorGuard","JsonRpcSigner","constructorGuard","addressOrIndex","connect","connectUnchecked","UncheckedJsonRpcSigner","_address","_index","send","accounts","sendUncheckedTransaction","fromAddress","estimate","sender","hexlifyTransaction","signTransaction","signMessage","_legacySignMessage","_signTypedData","domain","types","populated","resolveNames","getPayload","unlock","password","allowedTransactionKeys","networkOrReady","freeze","_nextId","_cache","_eventLoopCache","_uncachedDetectNetwork","serverError","getSigner","getUncheckedSigner","listAccounts","a","request","id","jsonrpc","action","cache","connection","response","prepareRequest","feeData","getFeeData","_startPending","_pendingFilter","self","pendingFilter","filterId","hashes","seq","allowExtra","allowed","StaticJsonRpcProvider","_super","create","get"],"sourceRoot":""}